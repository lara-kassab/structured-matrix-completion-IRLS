%% -------------- sIRLS-p algorithm ----------------------------- %%
% ----- KARTHIK MOHAN (karna@uw.edu)---------%
% -------------- LAST UPDATE: 6/26/2012 ------------------------------ %


function [NS, avgerr,avgiterno, TT,timeperiter, TTcpu] = sirls_p(n,sr,r,rmax,rknown,eta,gam0,gammin,tol,nrg)



%% PARAMETERS
 
if(rknown == 1)
countstart = r; %-- r if rank known
else
countstart = rmax; %-- rmax if rank NOT known
end;
TT = 0;TTcpu = 0; NS = 0;%# succesful instances
err = 0; avgerr = 0; avgiterno = 0; 
Errplot = zeros(niter,1);

for(ng = 1: nrg)
    
%% GENERATE MATRIX COMPLETION OPERATOR AND LOW RANK MATRIX X0    
Y1 = randn(n,r); Y2 = randn(n,r);
X01 = Y1*Y2'; X0 = X01/norm(X01); gam = gam0*norm(X0);

OM = binornd(1,sr,n,n);
[alp,beta] = find(OM==1); %vectors defining support Omega
[betat,alpt] = find(OM' == 1); 
p1 = size(alp,1); %NUMBER OF MEASUREMNTS TAKEN ~= p*n*n
CO = size(n,1);
count = 0;

%% MEASUREMENTS

B = zeros(n,n);
for(i = 1:p1)
    B(alpt(i),betat(i)) = X0(alpt(i),betat(i));
end;
for(i = 1:n)
    CO(i,1)= size(find(alpt == i),1);
end;
D = CO((CO > 0));



%% sIRLS FOR MATRIX COMPLETION PROBLEM


%FIRST ITERATION OF sIRLS
m = 1;
Xerr = 0; 
Xnew = B; Xold = B;
svditer =  niter; %Just one type of intermediate iteration in randsvdtropp
count = countstart;
     [U,S,V] = randsvdtropp(Xnew,count,m,svditer,incr);
     s = diag(S); si = size(s,1); g = gam*ones(si,1);
     D1 = diag( -(s.*s)./(s.*s + g));


L = 2; %INITIAL Lipschitz constant
V = 0; D1 = 0;
count_inc = 0; relerrnew = 0; relerrold = 0; extra_rank = 0;
tstart = cputime;
startclock = clock; 
while(m<niter)

    count3 = 0;
    relerrold = relerrnew;
    [Xnew,err,terr,k] = grad_proj(B,L,Xnew,V,D1,n,alpt,betat,gam,svditer,m);
    tf = 2:1:k-1;
    relerrnew = norm(Xnew - Xold,'fro');
    Xold = Xnew;
    
     [U,S,V] = randsvdtropp(Xnew,count,m,svditer,incr);
     s = diag(S);
     g = gam*ones(count,1); s = s(1:count,1);
     D1 = diag( -(s.*s)./(s.*s + g));
     V = V(:,1:count);
    
     count = min(size(find(s > max(s)*1e-2),1)+extra_rank,rmax);
     if(rknown == 1)
         count = r;
     end;
      
    L = 2; %LIPSCHITZ CONSTANT
    err = norm(Xnew - X0,'fro')/norm(X0,'fro');
    Errplot(m,1) = err;
    gam = max(gam/eta,gammin);
    m = m + 1;
    if(mod(m,10) == 0)
        if(err < tol)
            break
        end;
    end;
end;

if(err < tol)
avgerr = err + avgerr;
avgiterno = m + avgiterno;
TTcpu = TTcpu + cputime - tstart; 
TT = TT + etime(clock,startclock);
NS = NS + 1;
end;

end;

if(NS > 0)
TTcpu = TTcpu/NS;
TT = TT/NS;
avgerr = avgerr/NS;
avgiterno = avgiterno/NS;
timeperiter = TT/avgiterno;
else
TTcpu = cputime - tstart;
TT = etime(clock,startclock);
avgerr = err;
avgiterno = m;
timeperiter = TT/avgiterno;    
end;

   